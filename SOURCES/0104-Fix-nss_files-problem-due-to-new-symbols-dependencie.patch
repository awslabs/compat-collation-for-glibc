From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Benjamin Herrenschmidt <benh@amazon.com>
Date: Wed, 18 Aug 2021 20:49:21 +0000
Subject: [PATCH] Fix nss_files problem due to new symbols dependencies

Following "nss_files: Fix re-reading of long lines [BZ #18991]",
nss_files depends on new symbols exported from glibc.

This causes a problem when updating glibc on a running system:
Existing programs still have the old version loaded, without those
symbols, and may try to dynamically load the nss modules, which
will fail since this will be the new modules.

This works around it by having nss_files try to dynamically "find"
those symbols using dlsym() and fallback to the old implementation
if they aren't there.

diff --git a/nss/nss_files/files-XXX.c b/nss/nss_files/files-XXX.c
index c6ec1a8458a51e07febfe725303f463d19cf826c..9c561a3ba625ac3e23dbf1459ae8b6f09363922f 100644
--- a/nss/nss_files/files-XXX.c
+++ b/nss/nss_files/files-XXX.c
@@ -21,6 +21,7 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <libc-lock.h>
+#include <gnu/lib-names.h>
 #include "nsswitch.h"
 
 #include <kernel-features.h>
@@ -126,13 +127,119 @@ CONCAT(_nss_files_end,ENTNAME) (void)
 
   return NSS_STATUS_SUCCESS;
 }
-
+
+typedef enum
+{
+  gcr_ok = 0,
+  gcr_error = -1,
+  gcr_overflow = -2
+} get_contents_ret;
+
+/* Hack around the fact that fgets only accepts int sizes.  */
+static get_contents_ret
+get_contents (char *linebuf, size_t len, FILE *stream)
+{
+  size_t remaining_len = len;
+  char *curbuf = linebuf;
+
+  do
+    {
+      int curlen = ((remaining_len > (size_t) INT_MAX) ? INT_MAX
+		    : remaining_len);
+
+      /* Terminate the line so that we can test for overflow.  */
+      ((unsigned char *) curbuf)[curlen - 1] = 0xff;
+
+      char *p = fgets_unlocked (curbuf, curlen, stream);
+
+      /* EOF or read error.  */
+      if (p == NULL)
+        return gcr_error;
+
+      /* Done reading in the line.  */
+      if (((unsigned char *) curbuf)[curlen - 1] == 0xff)
+        return gcr_ok;
+
+      /* Drop the terminating '\0'.  */
+      remaining_len -= curlen - 1;
+      curbuf += curlen - 1;
+    }
+  /* fgets copies one less than the input length.  Our last iteration is of
+     REMAINING_LEN and once that is done, REMAINING_LEN is decremented by
+     REMAINING_LEN - 1, leaving the result as 1.  */
+  while (remaining_len > 1);
+
+  /* This means that the current buffer was not large enough.  */
+  return gcr_overflow;
+}
+
+/* Parsing the database file into `struct STRUCTURE' data structures.  */
+static enum nss_status
+internal_getent_old (FILE *stream, struct STRUCTURE *result,
+		     char *buffer, size_t buflen, int *errnop H_ERRNO_PROTO
+		     EXTRA_ARGS_DECL)
+{
+  char *p;
+  struct parser_data *data = (void *) buffer;
+  size_t linebuflen = buffer + buflen - data->linebuffer;
+  int parse_result;
+
+  if (buflen < sizeof *data + 2)
+    {
+      *errnop = ERANGE;
+      H_ERRNO_SET (NETDB_INTERNAL);
+      return NSS_STATUS_TRYAGAIN;
+    }
+
+  do
+    {
+      get_contents_ret r = get_contents (data->linebuffer, linebuflen, stream);
+
+      if (r == gcr_error)
+	{
+	  /* End of file or read error.  */
+	  H_ERRNO_SET (HOST_NOT_FOUND);
+	  return NSS_STATUS_NOTFOUND;
+	}
+
+      if (r == gcr_overflow)
+	{
+	  /* The line is too long.  Give the user the opportunity to
+	     enlarge the buffer.  */
+	  *errnop = ERANGE;
+	  H_ERRNO_SET (NETDB_INTERNAL);
+	  return NSS_STATUS_TRYAGAIN;
+	}
+
+      /* Everything OK.  Now skip leading blanks.  */
+      p = data->linebuffer;
+      while (isspace (*p))
+	++p;
+    }
+  while (*p == '\0' || *p == '#' /* Ignore empty and comment lines.  */
+	 /* Parse the line.  If it is invalid, loop to get the next
+	    line of the file to parse.  */
+	 || ! (parse_result = parse_line (p, result, data, buflen, errnop
+					  EXTRA_ARGS)));
+
+  if (__glibc_unlikely (parse_result == -1))
+    {
+      H_ERRNO_SET (NETDB_INTERNAL);
+      return NSS_STATUS_TRYAGAIN;
+    }
+
+  /* Filled in RESULT with the next entry from the database file.  */
+  return NSS_STATUS_SUCCESS;
+}
+
+static __typeof__(__libc_readline_unlocked) (*__libc_readline_unlocked_p);
+static __typeof__(__fseeko64) (*__fseeko64_p);
 
 /* Parsing the database file into `struct STRUCTURE' data structures.  */
 static enum nss_status
-internal_getent (FILE *stream, struct STRUCTURE *result,
-		 char *buffer, size_t buflen, int *errnop H_ERRNO_PROTO
-		 EXTRA_ARGS_DECL)
+internal_getent_new (FILE *stream, struct STRUCTURE *result,
+	char *buffer, size_t buflen, int *errnop H_ERRNO_PROTO
+	EXTRA_ARGS_DECL)
 {
   char *p;
   struct parser_data *data = (void *) buffer;
@@ -148,7 +255,7 @@ internal_getent (FILE *stream, struct STRUCTURE *result,
 
   while (true)
     {
-      ssize_t r = __libc_readline_unlocked
+	ssize_t r = __libc_readline_unlocked_p
 	(stream, data->linebuffer, linebuflen);
       if (r < 0)
 	{
@@ -188,7 +295,7 @@ internal_getent (FILE *stream, struct STRUCTURE *result,
 	      /* Return to the original file position at the beginning
 		 of the line, so that the next call can read it again
 		 if necessary.  */
-	      if (__fseeko64 (stream, -r, SEEK_CUR) != 0)
+	      if (__fseeko64_p (stream, -r, SEEK_CUR) != 0)
 		{
 		  if (errno == ERANGE)
 		    *errnop = EINVAL;
@@ -212,6 +319,39 @@ internal_getent (FILE *stream, struct STRUCTURE *result,
 }
 
 
+static struct link_map *glibc_handle;
+
+static void __attribute__((constructor)) init_nss_files(void)
+{
+    glibc_handle = __libc_dlopen (LIBC_SO);
+    if (!glibc_handle)
+      return;
+    __libc_readline_unlocked_p = __libc_dlsym(glibc_handle, "__libc_readline_unlocked");
+    __fseeko64_p = __libc_dlsym(glibc_handle, "__fseeko64");
+    if (!__libc_readline_unlocked_p || !__fseeko64_p)
+      {
+        __libc_readline_unlocked_p = NULL;
+	__fseeko64_p = NULL;
+      }
+}
+
+static void __attribute__((destructor)) exit_nss_files(void)
+{
+    if (glibc_handle)
+      __libc_dlclose(glibc_handle);
+}
+
+static inline enum nss_status
+internal_getent (FILE *stream, struct STRUCTURE *result,
+		 char *buffer, size_t buflen, int *errnop H_ERRNO_PROTO
+		 EXTRA_ARGS_DECL)
+{
+    if (__libc_readline_unlocked_p)
+      return internal_getent_new(stream, result, buffer, buflen, errnop H_ERRNO_ARG EXTRA_ARGS);
+    else
+      return internal_getent_old(stream, result, buffer, buflen, errnop H_ERRNO_ARG EXTRA_ARGS);
+}
+
 /* Return the next entry from the database file, doing locking.  */
 enum nss_status
 CONCAT(_nss_files_get,ENTNAME_r) (struct STRUCTURE *result, char *buffer,
